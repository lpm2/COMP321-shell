Xin Huang 	xyh1
Leo Meister	lpm2
COMP 321 Project 4: Unix Shell
3/12/15

DESCRIPTION

We designed a shell with limited functionality compared to shells like bash and csh. It is capable of running four built-in commands (quit, bg, fg, and jobs), as well as executable files. The command "quit" exits out of the shell, "bg" runs a given stopped command in the background, "fg" runs a given background or stopped command in the foreground, and jobs lists the jobs currently running. 

The shell will execute an executable file as long as the path to the executable is provided as the first argument on the command line or the path to the executable is on the search path (PATH environment variable). Jobs will be run in the background if the command ends with "&"

Examples:

//This will execute assuming the echo executable is in the bin directory
tsh> /bin/echo your string here

or

//This will execute assuming /bin/echo is in the PATH environment variable
tsh> echo your string here

//This will run the "foo" in the background
tsh> ./foo &


Typing CTRL-z will suspend the job running in the foreground, and typing CTRL-c will terminate any job running in the foreground. If any job is stopped or terminated by a signal, a message will display with the job id, process id, and command line arguments of that job.

DESIGN

For our the built-in commands of our shell, we used strcmp to check the if the
first argument given was any of the 4 built in commands and if any of them
were matched, we would run the appropriate function, either listjobs, exit, or
do_bgfg. For do_bgfg, we had a few corner case error/invalid print statements 
to take care of, so we created a flag that gets set depending on whether the 
argument passed was a pid, jid, or invalid, so we can print the appropriate 
message in line with what the reference passes.

TESTING STRATEGY

Again our testing strategy was pretty manual, as we had to check our 
implementation of tsh against the reference. For our simple tests, we ran tsh
and tshref through all the provided trace files and made sure that the output
of our tsh matched the output of the provided tshref. We also ran the provided 
functions of mystop, myspin, myint, etc and made sure those were working to 
spec with the reference as well. Then we tested the commands in the trace 
files and c files manually in our tsh to make sure they were working
when typed into the shell too. We then tested other commands such as ls, ps, 
and echo and made sure that the expected output was received. We then 
extensively tested the built in functions we wrote, especially "bg" and "fg"
as "quit" and "jobs" was not as complex. We ran bg and fg without arguments 
and also ran bg and fg with invalid pid / jid numbers and invalid string
arguments. We matched the reference invalid prints. Then we ran the the 
provided c programs in our tsh in both the foreground and background, stopped 
them with keyboard interrupts and stops to first make sure they would 
terminate or quit. Then we restarted the programs in all combinations of the 
background and foreground process. By now, we were sure our built in functions
were working properly, as well our error messages, and signal interrupts. So
we decided to test what would happen if we gave our shell an empty path, and 
found that that worked to spec as well as it would take the current directory
as the path and was able to run programs in the current directory without a
a path. With that tested, we were pretty confident that our shell was working
and we made a few extra trace files that were essentially longer combinations
of a few of the provided trace files and programs. We tested our own created 
trace files and confirmed they were able to complete and terminate in both 
our tsh and the tshref.
